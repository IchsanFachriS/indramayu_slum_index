{
  "version": 3,
  "sources": ["../../xml-utils/get-attribute.mjs", "../../xml-utils/index-of-match.mjs", "../../xml-utils/index-of-match-end.mjs", "../../xml-utils/count-substring.mjs", "../../xml-utils/find-tag-by-name.mjs", "../../xml-utils/find-tags-by-name.mjs", "../../xml-utils/find-tags-by-path.mjs", "../../xml-utils/find-tag-by-path.mjs", "../../xml-utils/remove-comments.mjs"],
  "sourcesContent": ["export default function getAttribute(tag, attributeName, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] getting \" + attributeName + \" in \" + tag);\n\n  const xml = typeof tag === \"object\" ? tag.outer : tag;\n\n  // only search for attributes in the opening tag\n  const opening = xml.slice(0, xml.indexOf(\">\") + 1);\n\n  const quotechars = ['\"', \"'\"];\n  for (let i = 0; i < quotechars.length; i++) {\n    const char = quotechars[i];\n    const pattern = attributeName + \"\\\\=\" + char + \"([^\" + char + \"]*)\" + char;\n    if (debug) console.log(\"[xml-utils] pattern:\", pattern);\n\n    const re = new RegExp(pattern);\n    const match = re.exec(opening);\n    if (debug) console.log(\"[xml-utils] match:\", match);\n    if (match) return match[1];\n  }\n}\n", "export default function indexOfMatch(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index;\n  else return -1;\n}\n", "export default function indexOfMatchEnd(xml, pattern, startIndex) {\n  const re = new RegExp(pattern);\n  const match = re.exec(xml.slice(startIndex));\n  if (match) return startIndex + match.index + match[0].length - 1;\n  else return -1;\n}\n", "export default function countSubstring(string, substring) {\n  const pattern = new RegExp(substring, \"g\");\n  const match = string.match(pattern);\n  return match ? match.length : 0;\n}\n", "import indexOfMatch from \"./index-of-match.mjs\";\nimport indexOfMatchEnd from \"./index-of-match-end.mjs\";\nimport countSubstring from \"./count-substring.mjs\";\n\nexport default function findTagByName(xml, tagName, options) {\n  const debug = (options && options.debug) || false;\n  const nested = !(options && typeof options.nested === false);\n\n  const startIndex = (options && options.startIndex) || 0;\n\n  if (debug) console.log(\"[xml-utils] starting findTagByName with\", tagName, \" and \", options);\n\n  const start = indexOfMatch(xml, `\\<${tagName}[ \\n\\>\\/]`, startIndex);\n  if (debug) console.log(\"[xml-utils] start:\", start);\n  if (start === -1) return undefined;\n\n  const afterStart = xml.slice(start + tagName.length);\n\n  let relativeEnd = indexOfMatchEnd(afterStart, \"^[^<]*[ /]>\", 0);\n\n  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === \"/\";\n  if (debug) console.log(\"[xml-utils] selfClosing:\", selfClosing);\n\n  if (selfClosing === false) {\n    // check if tag has subtags with the same name\n    if (nested) {\n      let startIndex = 0;\n      let openings = 1;\n      let closings = 0;\n      while ((relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", startIndex)) !== -1) {\n        const clip = afterStart.substring(startIndex, relativeEnd + 1);\n        openings += countSubstring(clip, \"<\" + tagName + \"[ \\n\\t>]\");\n        closings += countSubstring(clip, \"</\" + tagName + \">\");\n        // we can't have more openings than closings\n        if (closings >= openings) break;\n        startIndex = relativeEnd;\n      }\n    } else {\n      relativeEnd = indexOfMatchEnd(afterStart, \"[ /]\" + tagName + \">\", 0);\n    }\n  }\n\n  const end = start + tagName.length + relativeEnd + 1;\n  if (debug) console.log(\"[xml-utils] end:\", end);\n  if (end === -1) return undefined;\n\n  const outer = xml.slice(start, end);\n  // tag is like <gml:identifier codeSpace=\"OGP\">urn:ogc:def:crs:EPSG::32617</gml:identifier>\n\n  let inner;\n  if (selfClosing) {\n    inner = null;\n  } else {\n    inner = outer.slice(outer.indexOf(\">\") + 1, outer.lastIndexOf(\"<\"));\n  }\n\n  return { inner, outer, start, end };\n}\n", "import findTagByName from \"./find-tag-by-name.mjs\";\n\nexport default function findTagsByName(xml, tagName, options) {\n  const tags = [];\n  const debug = (options && options.debug) || false;\n  const nested = options && typeof options.nested === \"boolean\" ? options.nested : true;\n  let startIndex = (options && options.startIndex) || 0;\n  let tag;\n  while ((tag = findTagByName(xml, tagName, { debug, startIndex }))) {\n    if (nested) {\n      startIndex = tag.start + 1 + tagName.length;\n    } else {\n      startIndex = tag.end;\n    }\n    tags.push(tag);\n  }\n  if (debug) console.log(\"findTagsByName found\", tags.length, \"tags\");\n  return tags;\n}\n", "import findTagsByName from \"./find-tags-by-name.mjs\";\n\nexport default function findTagsByPath(xml, path, options) {\n  const debug = (options && options.debug) || false;\n  if (debug) console.log(\"[xml-utils] starting findTagsByPath with: \", xml.substring(0, 500));\n  const returnOnFirst = (options && options.returnOnFirst) || false;\n\n  if (Array.isArray(path) === false) throw new Error(\"[xml-utils] path should be an array\");\n\n  const path0 = typeof path[0] === \"string\" ? { name: path[0] } : path[0];\n  let tags = findTagsByName(xml, path0.name, { debug, nested: false });\n  if (typeof tags !== \"undefined\" && typeof path0.index === \"number\") {\n    if (typeof tags[path0.index] === \"undefined\") {\n      tags = [];\n    } else {\n      tags = [tags[path0.index]];\n    }\n  }\n  if (debug) console.log(\"first tags are:\", tags);\n\n  path = path.slice(1);\n\n  for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {\n    const part = typeof path[pathIndex] === \"string\" ? { name: path[pathIndex] } : path[pathIndex];\n    if (debug) console.log(\"part.name:\", part.name);\n    let allSubTags = [];\n    for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {\n      const tag = tags[tagIndex];\n      const subTags = findTagsByName(tag.outer, part.name, {\n        debug,\n        startIndex: 1\n      });\n\n      if (debug) console.log(\"subTags.length:\", subTags.length);\n      if (subTags.length > 0) {\n        subTags.forEach(subTag => {\n          (subTag.start += tag.start), (subTag.end += tag.start);\n        });\n        if (returnOnFirst && pathIndex === path.length - 1) return [subTags[0]];\n        allSubTags = allSubTags.concat(subTags);\n      }\n    }\n    tags = allSubTags;\n    if (typeof part.index === \"number\") {\n      if (typeof tags[part.index] === \"undefined\") {\n        tags = [];\n      } else {\n        tags = [tags[part.index]];\n      }\n    }\n  }\n  return tags;\n}\n", "import findTagsByPath from \"./find-tags-by-path.mjs\";\n\nexport default function findTagByPath(xml, path, options) {\n  const debug = (options && options.debug) || false;\n  const found = findTagsByPath(xml, path, { debug, returnOnFirst: true });\n  if (Array.isArray(found) && found.length === 1) return found[0];\n  else return undefined;\n}\n", "export default function removeComments(xml) {\n  return xml.replace(/<!--[^]*-->/g, \"\");\n}\n"],
  "mappings": "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",
  "names": ["startIndex"]
}
