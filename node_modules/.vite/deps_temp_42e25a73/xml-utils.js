import "./chunk-G3PMV62Z.js";

// node_modules/xml-utils/get-attribute.mjs
function getAttribute(tag, attributeName, options) {
  const debug = options && options.debug || false;
  if (debug) console.log("[xml-utils] getting " + attributeName + " in " + tag);
  const xml = typeof tag === "object" ? tag.outer : tag;
  const opening = xml.slice(0, xml.indexOf(">") + 1);
  const quotechars = ['"', "'"];
  for (let i = 0; i < quotechars.length; i++) {
    const char = quotechars[i];
    const pattern = attributeName + "\\=" + char + "([^" + char + "]*)" + char;
    if (debug) console.log("[xml-utils] pattern:", pattern);
    const re = new RegExp(pattern);
    const match = re.exec(opening);
    if (debug) console.log("[xml-utils] match:", match);
    if (match) return match[1];
  }
}

// node_modules/xml-utils/index-of-match.mjs
function indexOfMatch(xml, pattern, startIndex) {
  const re = new RegExp(pattern);
  const match = re.exec(xml.slice(startIndex));
  if (match) return startIndex + match.index;
  else return -1;
}

// node_modules/xml-utils/index-of-match-end.mjs
function indexOfMatchEnd(xml, pattern, startIndex) {
  const re = new RegExp(pattern);
  const match = re.exec(xml.slice(startIndex));
  if (match) return startIndex + match.index + match[0].length - 1;
  else return -1;
}

// node_modules/xml-utils/count-substring.mjs
function countSubstring(string, substring) {
  const pattern = new RegExp(substring, "g");
  const match = string.match(pattern);
  return match ? match.length : 0;
}

// node_modules/xml-utils/find-tag-by-name.mjs
function findTagByName(xml, tagName, options) {
  const debug = options && options.debug || false;
  const nested = !(options && typeof options.nested === false);
  const startIndex = options && options.startIndex || 0;
  if (debug) console.log("[xml-utils] starting findTagByName with", tagName, " and ", options);
  const start = indexOfMatch(xml, `<${tagName}[ 
>/]`, startIndex);
  if (debug) console.log("[xml-utils] start:", start);
  if (start === -1) return void 0;
  const afterStart = xml.slice(start + tagName.length);
  let relativeEnd = indexOfMatchEnd(afterStart, "^[^<]*[ /]>", 0);
  const selfClosing = relativeEnd !== -1 && afterStart[relativeEnd - 1] === "/";
  if (debug) console.log("[xml-utils] selfClosing:", selfClosing);
  if (selfClosing === false) {
    if (nested) {
      let startIndex2 = 0;
      let openings = 1;
      let closings = 0;
      while ((relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", startIndex2)) !== -1) {
        const clip = afterStart.substring(startIndex2, relativeEnd + 1);
        openings += countSubstring(clip, "<" + tagName + "[ \n	>]");
        closings += countSubstring(clip, "</" + tagName + ">");
        if (closings >= openings) break;
        startIndex2 = relativeEnd;
      }
    } else {
      relativeEnd = indexOfMatchEnd(afterStart, "[ /]" + tagName + ">", 0);
    }
  }
  const end = start + tagName.length + relativeEnd + 1;
  if (debug) console.log("[xml-utils] end:", end);
  if (end === -1) return void 0;
  const outer = xml.slice(start, end);
  let inner;
  if (selfClosing) {
    inner = null;
  } else {
    inner = outer.slice(outer.indexOf(">") + 1, outer.lastIndexOf("<"));
  }
  return { inner, outer, start, end };
}

// node_modules/xml-utils/find-tags-by-name.mjs
function findTagsByName(xml, tagName, options) {
  const tags = [];
  const debug = options && options.debug || false;
  const nested = options && typeof options.nested === "boolean" ? options.nested : true;
  let startIndex = options && options.startIndex || 0;
  let tag;
  while (tag = findTagByName(xml, tagName, { debug, startIndex })) {
    if (nested) {
      startIndex = tag.start + 1 + tagName.length;
    } else {
      startIndex = tag.end;
    }
    tags.push(tag);
  }
  if (debug) console.log("findTagsByName found", tags.length, "tags");
  return tags;
}

// node_modules/xml-utils/find-tags-by-path.mjs
function findTagsByPath(xml, path, options) {
  const debug = options && options.debug || false;
  if (debug) console.log("[xml-utils] starting findTagsByPath with: ", xml.substring(0, 500));
  const returnOnFirst = options && options.returnOnFirst || false;
  if (Array.isArray(path) === false) throw new Error("[xml-utils] path should be an array");
  const path0 = typeof path[0] === "string" ? { name: path[0] } : path[0];
  let tags = findTagsByName(xml, path0.name, { debug, nested: false });
  if (typeof tags !== "undefined" && typeof path0.index === "number") {
    if (typeof tags[path0.index] === "undefined") {
      tags = [];
    } else {
      tags = [tags[path0.index]];
    }
  }
  if (debug) console.log("first tags are:", tags);
  path = path.slice(1);
  for (let pathIndex = 0; pathIndex < path.length; pathIndex++) {
    const part = typeof path[pathIndex] === "string" ? { name: path[pathIndex] } : path[pathIndex];
    if (debug) console.log("part.name:", part.name);
    let allSubTags = [];
    for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {
      const tag = tags[tagIndex];
      const subTags = findTagsByName(tag.outer, part.name, {
        debug,
        startIndex: 1
      });
      if (debug) console.log("subTags.length:", subTags.length);
      if (subTags.length > 0) {
        subTags.forEach((subTag) => {
          subTag.start += tag.start, subTag.end += tag.start;
        });
        if (returnOnFirst && pathIndex === path.length - 1) return [subTags[0]];
        allSubTags = allSubTags.concat(subTags);
      }
    }
    tags = allSubTags;
    if (typeof part.index === "number") {
      if (typeof tags[part.index] === "undefined") {
        tags = [];
      } else {
        tags = [tags[part.index]];
      }
    }
  }
  return tags;
}

// node_modules/xml-utils/find-tag-by-path.mjs
function findTagByPath(xml, path, options) {
  const debug = options && options.debug || false;
  const found = findTagsByPath(xml, path, { debug, returnOnFirst: true });
  if (Array.isArray(found) && found.length === 1) return found[0];
  else return void 0;
}

// node_modules/xml-utils/remove-comments.mjs
function removeComments(xml) {
  return xml.replace(/<!--[^]*-->/g, "");
}
export {
  findTagByName,
  findTagByPath,
  findTagsByName,
  findTagsByPath,
  getAttribute,
  removeComments
};
//# sourceMappingURL=xml-utils.js.map
